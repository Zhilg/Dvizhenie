ВАЖНО!!!
===========================================================================


В /clusterisation пока возвращается Mock-ответ

**Для правильной работы оболочки с контейнерами разработчиков необходимо поменять поле image в графе back-service в файле docker-compose.yml на имя вашего контейнера. Порт контейнера обязан быть равным 3000.**

Оболочка обращается к вашему контейнеру в виде запроса на http://back-service:3000/api/<доменное имя>. 

Разработчики должны отправлять **один** контейнер, который обрабатывает нижеперечисленные запросы.

НОВОЕ API НИЖЕ

API Документация 
===========================================================================

Настоящее API определяет функциональность программного модуля семантической обработки данных "ПМ Семантика", далее - ПМ
ПМ запускается в виде докер-контейнера с монтированием тома для обмена данными
Обмен производится по HTTP в соответствие с принципами REST с исключением: для обмена файлов большого объёма используется смонтированный том.


Запросы общей гарантированной продолжительностью менее 2 минут выполняются в синхронными режиме.

Запросы возможной продолжительность более 2 минут выполняются в асинхронном режиме. В этом случае задаче присваивается идентификатор, в дальнейшем по этому идентификатору выдаётся статус, после готовности результата вместе со статусом выдается ссылка на результат.


---------------------------------------------------------------------------
1. POST /normalize

Описание:

Синхронная нормализация текста:
1. Принимает текст в формате **UTF-8**
2. Выполняет:
   - Удаление лишних пробелов, служебных символов, различных лингвистических конструкций, не имеющих смысловой нагрузки
   - Коррекцию переносов строк
   - Удаление стоп-слов
3. Возвращает нормализованный текст

Запрос:
```
POST /normalize HTTP/1.1
content-type: text/plain;

BODY:
Текст в кодировке UTF-8
```

Ответ:
```
HTTP/1.1 200 OK

content-type: text/plain
language: ru (двухбуквенное значение определённого в процессе обработки языка текста в нотации ISO-639-1)

BODY: 
Нормализованный текст в кодировке UTF-8
```
Ошибки:
- 400 INVALID_ENCODING: неподдерживаемая кодировка
- 413 PAYLOAD_TOO_LARGE: текст превышает 10MB
- 429: слишком много запросов
- 5xx - ошибка сервера

---------------------------------------------------------------------------
2. POST /embedding

Описание:

Векторизация текста, в синхронном режиме
1. Принимает текст в формате **UTF-8**
2. Выполняет нормализацию текста с использованием метода /normalize
3. Вычисляет векторно-матричную форму нормализованного текста, отображающую смысл выбранного текста. 

Запрос:
```
POST /embedding HTTP/1.1
content-type: text/plain;
x-model-id: uuid, идентификатор модели, на основании которого следует векторизовать текст. Применяется модель, полученная из списка /models

BODY: 
Текст в кодировке UTF-8
```

Ответ:
```
HTTP/1.1 200 OK:

{
  "embeddings": [0.123, 0.456, ...], # Значения вектора.
  "dimension": 512, # Размер вектора
}
```
Ошибки:
- 400 INVALID_ENCODING: неподдерживаемая кодировка
- 404: не найдена модель: model_id
- 413 PAYLOAD_TOO_LARGE: текст превышает 10MB
- 429: слишком много запросов
- 5xx - ошибка сервера

---------------------------------------------------------------------------
3. GET /models

Описание:

Получить список доступных моделей

Запрос:
```HTTP
GET /models HTTP/1.1
```

Ответ:
```:
HTTP/1.1 200 OK:

[ 
  {
    "model_id": "UUID", # идентификатор модели (обязательно)
    "model_name": "bert-multilinguial", # наименование модели (опционально)
    "dimension": "размерность вектора получаемого при эмбеддинге"
  },
  ...
]
```
---------------------------------------------------------------------------
4. POST /semantic/upload

Описание:

Асинхронная загрузка корпуса документов (до 100GB).

Применяется для последующего использования корпуса в других запросах.

После загрузки происходит:
1. Чтение иерархии файлов в файловой системе. Возможные типы файлов:
 Текстовые. Формат: txt - кодировка - UTF-8
2. Векторизация документов (По абзацам/документам/любым другим единицам на усмотрение разработчика)

Запрос:
```HTTP
POST /semantic/upload HTTP/1.1
content-type: application/json (обязательный)
x-corpus-path: относительный путь к каталогу с файлами. Путь указывается относительно точки монтирования докера ПМ (обязательный). Точка монтирования - папка ~/shared_data. Папка создается с именем, равным UUID корпуса уже в оболочке.
x-model-id: - идентификатор модели (обязательный)
x-ttl-hours: - количество часов, по истечении  которых можно удалять производные данные. 0 или не указано - не удалять. (необязательный)
```

Ответ:
```
HTTP/1.1 202 ACCEPTED:

{
  "job_id": "123e4567-e89b-12d3-a456-426614174000", # обязательный
  "estimated_time_min": 120, # необязательный
}
```
Получение статуса обработки
```HTTP
GET /api/jobs/{job_id} HTTP/1.1
```
Статусы обработки:

1. В процессе:
```
HTTP/1.1 200 OK:

{
  "status": "processing", #обязательный
  "progress": 45.2, #необязательный
  "details": { #необязательный
    "bytes_processed": 48318382080,
    "files_processed": 12450
  }
}
```
2. Успешно:
```
HTTP/1.1 200 OK:

{
  "status": "completed",
  "result_url": "http:///" # ссылка на результат"
}
```

Получение результата:
```HTTP
GET /result/url HTTP/1.1
```

Формат результата:
```
HTTP/1.1 200 OK:

{
    "corpus_id": UUID, #созданный идентификатор корпуса
    "file_count": 30000,
    "index_stats": 
    {
      "total_size_gb": 95.4,
    }
}
```
Ошибки:
- 404:
     1. Каталог не найден
     2. Каталог пустой
     3. Модель не найдена
- 5xx: ошибка на сервере

---------------------------------------------------------------------------
5. POST /semantic/search

Описание:

Синхронный семантический поиск по **структурированному** корпусу текстовых данных

После вызова происходит:
1. Нормализация поискового запроса с использованием метода /normalize
2. Векторизация запроса с использованием метода /embedding
3. Поиск по корпусу
4. Возврат результата поиска

Запрос:
```
POST /semantic/search HTTP/1.1
content-type: text/plain; charset=utf-8 (обязательный)
x-corpus-id: uuid, идентификатор корпуса, загруженного через /semantic/upload (обязательный)
x-result-amount: int, количество возвращаемых результатов поиска
x-model-id: идентификатор модели (обязательный)

BODY: 
текст в кодировке UTF-8
```
Ответ:
```
HTTP/1.1 200 OK:

{
  "results": [ 
    {
      "file_id": "doc123.txt", # Относительный путь до файла внутри корпуса
      "score": 0.87, # Степень смысловой схожести 
      "preview": "...контекстный фрагмент...", # 200 символов вокруг найденного фрагмента (Обязательно только в том случае, если разработчик векторизует тексты корпуса по абзацам)
       fragment: 'аннотация или заголовок', # 100 первых символов документа (никакой генерации, просто первые 100 символов найденного документа)
    }, ...
  ] # Массив результатов должен быть отсортирован в порядке убывания score 
}
```

Ошибки:
- 404:
     1. Корпус не найден
     3. Модель не найдена
- 5xx: ошибка на сервере

---------------------------------------------------------------------------
6. POST /semantic/search/unstructured

Описание:

Синхронный семантический поиск по **неструктурированному** корпусу текстовых данных

После вызова происходит:
1. Нормализация поискового запроса с использованием метода /normalize
2. Векторизация запроса с использованием метода /embedding
3. Поиск по корпусу
4. Возврат результата поиска

Запрос:
```
POST /semantic/search HTTP/1.1
content-type: text/plain; charset=utf-8 (обязательный)
x-corpus-id: uuid, идентификатор корпуса, загруженного через /semantic/upload (обязательный)
x-result-amount: int, количество возвращаемых результатов поиска
x-model-id: идентификатор модели (обязательный)

BODY: 
текст в кодировке UTF-8
```
Ответ:
```
HTTP/1.1 200 OK:

{
  "results": [ 
    {
      "file_id": "doc123.txt", # Относительный путь до файла внутри корпуса
      "score": 0.87, # Степень смысловой схожести 
      "preview": "...контекстный фрагмент...", # 200 символов вокруг найденного фрагмента (Обязательно только в том случае, если разработчик векторизует тексты корпуса по абзацам)
       fragment: 'аннотация или заголовок', # 100 первых символов документа (никакой генерации, просто первые 100 символов найденного документа)
    }, ...
  ] # Массив результатов должен быть отсортирован в порядке убывания score 
}
```

Ошибки:
- 404:
     1. Корпус не найден
     3. Модель не найдена
- 5xx: ошибка на сервере
  
---------------------------------------------------------------------------
7. POST /clusterisation

Описание:

Асинхронная кластеризация документов
Возможные типы файлов:
Текстовые. Формат: txt - кодировка - UTF-8.

Кластеризации подлежит тот же набор данных, что отдавали в /semantic/upload.

Количество кластеров определяется автоматически.


Запрос:
```
POST /clusterisation HTTP/1.1
content-type: application/json (обязательный)
x-corpus-path: относительный путь к каталогу с файлами. Путь указывается относительно точки монтирования докера ПМ (обязательный). Точка монтирования - папка shared_data
x-model-id: идентификатор модели (обязательный)
x-ttl-hours: количество часов, по истечении  которых можно удалять производные данные. 0 или не указано - не удалять. (необязательный)

```

Ответ:
```
HTTP/1.1 202 ACCEPTED:

{
  "job_id": "123e4567-e89b-12d3-a456-426614174000", #обязательный
  "estimated_time_min": 120 #необязательный
}
```

**Получение статуса и результата обработки такое же, как в POST /semantic/upload**

**Формат статуса обработки такой же, как в POST /semantic/upload**

Формат результата:
```
HTTP/1.1 200 OK:

{
  "folder": "C:/documents/text_corpus", # Путь к исходной папке относительно точки монтирования (точка монтирования - папка shared_data)
  "data": {
    "id": "root",                     # Технический корень (все файлы) (не связан с какой-либо файловой структурой, обозначает виртуальную точку входа в данные)
    "name": "Все кластеры",           # Название корневого узла
    "fileCount": 32456,               # Общее число файлов
    "avgSimilarity": 0.82,            # Средняя близость по всем файлам
    "children": [                     # Список ОСНОВНЫХ кластеров 1-го уровня (основные кластеры -- это самые крупные группы документов, на которые разбивается вся коллекция файлов. Они находятся непосредственно под корневым узлом ("id": "root").)
      {
        "id": "cluster1",
        "name": "Технологии",         # Название кластера, осмысленное название не обязательно, разрешается возвращать нумерацию
        "fileCount": 12480,            # Количество файлов в этом кластере
        "avgSimilarity": 0.87,         # Средняя близость внутри кластера
        "similarityDistribution": [0, 0.1, 0.2, 0.3, 0.4] # Массив из 5 чисел, где каждый элемент представляет долю (от 0.0 до 1.0) файлов в кластере, чья схожесть с центроидом попадает в один из интервалов: [0.0, 0.2), [0.2, 0.4), [0.4, 0.6), [0.6, 0.8), [0.8, 1.0]
                                                          # Массив [0, 0.1, 0.2, 0.3, 0.4] означает, что 0% файлов в кластере имеют долю схожести, лежащую в промежутке [0.0, 0.2), 10% файлов в кластеере имеют долю схожести, лежащую в промежутке [0.2, 0.4), 20% файлов в кластеере имеют долю схожести, лежащую в промежутке [0.4, 0.6), 
                                                          # 30% файлов в кластеере имеют долю схожести, лежащую в промежутке [0.6, 0.8) и 40% файлов в кластеере имеют долю схожести, лежащую в промежутке [0.8, 1]
        "files": [
          {
            "name": "ai_research.txt", # Имя файла, один и тот же файл может находиться в разных кластерах
          }, ...
        ],               # Файлы, напрямую входящие в этот кластер
        "children": [...]             # ПОДкластеры (например, "ИИ" внутри "Технологий"), структура такая же. Представляют собой разбиение основных кластеров на темы, могут также иметь неограниченное число детей.
      },
      {
        "id": "cluster2",
        "name": "Наука",
        ...                           # Аналогичная структура
      },
      ...
    ]
  }
   "graphic_respresentation": null/"url_сервиса_визуализации" # Разработчик отправляет ссылку на свой сервис отображения результатов кластеризации посредством их визуализации с помощью построения графики, необходимой и достаточной для наглядного объяснения получившихся результатов. Является отдельной задачей, в случае, если она не сделана, разрешается отправлять null.
   "planetar_representation": null/"url_сервиса_визуализации" # Аналогично полю "graphic_respresentation" за исключением того, что должна использоваться планетарная модель (2D или 3D).
   "drill-down_representation": null/"url_сервиса_визуализации" # Аналогично полю "graphic_respresentation" за исключением того, что должна использоваться drill-down модель.

}
```
Ошибки:
- 404: не найден каталог для обработки или каталог пустой
- 5xx: ошибка на сервере



