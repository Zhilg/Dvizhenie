===========================================================================
ВАЖНО!!!
В целях сохранения работы с контейнерами других разработчиков, пока оболочка отправляет запросы на:
/normalize - В виде

POST HTTP 1.1
Заголовки:
- content-type: 'application/json'
- x-requested-with: 'XMLHttpRequest'
Тело (JSON):
{
  text: текст в формате Base64
}
      
/embedding - В виде
POST HTTP 1.1
Заголовки:
- content-type: 'application/json'
Тело (JSON):
{
  text1: текст в формате Base64
  text2: текст в формате Base64
}

/semantic/upload - В виде
POST HTTP 1.1
Заголовки:
- 'Content-Type': 'application/json' 
Тело:
- folder_path: Путь к папке на стороне обработчика (Пример: /shared_data/{timestamp})
- collection_name: Имя коллекции
- processes: Количество процессов для обработки коллекции

/semantic/search - В виде
Заголовки:
- пусто
Тело:
- querry: Запрос (текст в формате Base64)
- collection_name: Имя коллекции, в которой будет производиться поиск
- top_k: Количество возвращаемых результатов (результаты поиска возвращаются в порядке убывания степеней схожести)            

НОВОЕ API НИЖЕ

API Документация 
===========================================================================

Настоящее API определяет функциональность программного модуля семантической обработки данных "ПМ Семантика", далее - ПМ
ПМ запускается в виде докер-контейнера с монтированием тома для обмена данными
Обмен производится по HTTP в соответствие с принципами REST с исключением: для обмена файлов большого объёма используется смонтированный том.


Запросы общей гарантированной продолжительностью менее 2 минут выполняются в синхронными режиме
Запросы возможной продолжительность более 2 минут выполняются в асинхронном режиме. В этом случае задаче присваивается идентификатор, в дальнейшем по этому идентификатору выдаётся статус, после готовности результата вместе со статусом выдается ссылка на результат.

---------------------------------------------------------------------------
1. POST /normalize

Описание:
Асинхронная нормализация текста:
1. Принимает текст в любом формате (plain text, base64, utf-8 и т.д.)
2. Выполняет:
   - Удаление лишних пробелов, служебных символов, различных лингвистических конструкций, не имеющих смысловой нагрузки
   - Коррекцию переносов строк
   - Удаление стоп-слов
3. Возвращает нормализованный текст

Входные параметры:
Заголовки:
- content-type: text/plain; charset=utf-8 (обязательный)

Тело запроса: 
текст в кодировке UTF-8

Возвращаемое значение (200):
Заголовки:
- content-type: text/plain; charset=utf-8 (обязательный)
- language: ru (двухбуквенное значение определённого в процессе обработки языка текста в нотации ISO-639-1)

Тело: нормализованный текст

Ошибки:
- 400 INVALID_ENCODING: неподдерживаемая кодировка
- 413 PAYLOAD_TOO_LARGE: текст превышает 10MB
- 429: слишком много запросов
- 5xx - ошибка сервера

---------------------------------------------------------------------------
2. GET /embedding

Описание:
Векторизация текста, в синхронном режиме
1. Принимает текст в  формате UTF-8
2. Выполняет нормализацию текста с использованием метода /normalize
3. Вычисляет векторно-матричную форму нормализованного текста, отображающую смысл выбранного текста. 

Входные параметры:
Заголовки:
- content-type: text/plain; charset=utf-8 (обязательный)
- model-id: uuid, идентификатор модели, на основании которого следует векторизовать текст. Применяется модель, полученная из списка /models

Тело запроса: 
 - текст в кодировке UTF-8

Возвращаемое значение (200):
Результат (JSON):
{
  "embeddings": [0.123, 0.456, ...], # Значения вектора. Диапазон зависит от модели
  "dimension": 512, # Размер вектора
}

Ошибки:
- 400 INVALID_ENCODING: неподдерживаемая кодировка
- 404: не найдена модель: model_id
- 413 PAYLOAD_TOO_LARGE: текст превышает 10MB
- 429: слишком много запросов
- 5xx - ошибка сервера

---------------------------------------------------------------------------
3. GET /models

Описание:
Получить список доступных моделей
Входные параметры:
- отсутствуют

Возвращаемое значение (200):
Результат (JSON):
[ 
  {
    "model_id": UUID, # идентификатор модели (обязательно)
    "model_name": "bert-multilinguial", # наименование модели (опционально)
  },
  ...
]

---------------------------------------------------------------------------
4. POST /semantic/upload

Описание:
Асинхронная загрузка корпуса документов (до 100GB).
Применяется для последующего использования корпуса в других запросах.

После загрузки происходит:
1. Чтение иерархии файлов в файловой системе. Возможные типы файлов:
 Текстовые. Формат: txt - кодировка - UTF-8
2. Векторизация документов (По абзацам/документам на усмотрение разработчика)

Входные параметры:
Заголовки:
- content-type: application/json (обязательный)
- x-corpus-path: относительный путь к каталогу с файлами. Путь указывается относительно точки монтирования докера ПМ (обязательный). Точка монтирования - папка shared_data
- x-model-id - идентификатор модели (обязательный)
- x-ttl-hours - количество часов, по истечении  которых можно удалять производные данные. 0 или не указано - не удалять. (необязательный)

Тело запроса:
- пусто 

Возвращаемое значение (202 Accepted):
{
  "job_id": "123e4567-e89b-12d3-a456-426614174000", #обязательный
  "estimated_time_min": 120 #необязательный
}

Статусы обработки:
1. В процессе:
{
  "status": "processing", #обязательный
  "progress": 45.2, #необязательный
  "details": { #необязательный
    "bytes_processed": 48318382080,
    "files_processed": 12450
  }
}

2. Успешно:
{
  "status": "completed",
  "result_url": "http:///" # ссылка на результат"
}

Формат результата:
{
    "corpus_id": UUID, #созданный идентификатор корпуса
    "file_count": 30000,
    "index_stats": 
    {
      "total_size_gb": 95.4,
      "formats": {
        "txt": 12000,
        "docx": 8000 ???????
      }
    }
}

Ошибки:
- 404: не найден каталог для обработки или каталог пустой
- 5xx: ошибка на сервере

---------------------------------------------------------------------------
5. POST /semantic/search

Описание:
Синхронный семантический поиск по корпусу
После вызова происходит:
1. Нормализация поискового запроса с использованием метода /normalize
2. Векторизация запроса с использованием метода /embedding
3. Поиск по корпусу
4. Возврат результата поиска

Входные параметры:
Заголовки:
- content-type: text/plain; charset=utf-8 (обязательный)
- corpus-id: uuid, идентификатор корпуса, загруженного через /semantic/upload (обязательный)

Тело запроса: 
 - текст в кодировке UTF-8

Результат (json):
{
  "results": [
    {
      "file_id": "doc123.txt", # Относительный путь до файла внутри корпуса
      "score": 0.87, # Степень смысловой схожести 
      "preview": "...контекстный фрагмент...", # 200 символов вокруг найденного фрагмента (Обязательно только в том случае, если разработчик векторизует тексты корпуса по абзацам)
       fragment: 'аннотация или заголовок', // 100 первых символов документа 
    }, ...
  ] # Массив результатов должен быть отсортирован в порядке убывания score 
}

===========================================================================

